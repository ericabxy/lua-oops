--- class module with new, init, and super functions
-- {module}.init is used to initialize new objects, but must be called
-- after creating the object. {module}.new is called to create a new
-- objects and new subclasses. {module}.super is used to call methods
-- on the superclass without creating and returning an object first.
-- This technique uses three separate functions on the module table to
-- demonstrate distinct use-cases without using any similar code. Its
-- possible to rewrite "init" to call "new" to create the object before
-- initializing it, and its possible to create an "extend" function to
-- take over the second functionality of "new".
-- @classmod {modname}
local {modname} = {{}}

-- class table
local {classname} = {{}}

-- constructor method
function {classname}:{classname}()
end

-- return an initialized object of class {classname}
-- usage: abc = {modname}.new(a, b, c).init()
function {modname}.init(self, ...)
  self:{classname}(...)
  return self
end

-- return a new object of class {classname}
-- usage: abc = {modname}.new({a = 1, b = 2, c = 3})
-- @param[option] o table of initial fields
function {modname}.new(o)
  local self = o or {{}}
  setmetatable(self, {{ __index = {classname} }})
  return self
end

-- call a method on the parent class
-- usage: 
function {modname}.super(method, self, ...)
  return {classname}[method](self, ...)
end

return {modname}
